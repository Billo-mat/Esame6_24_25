import matplotlib.pyplot as plt
import numpy as np
from typing import List, Tuple
import pandas as pd
import pymc as pm
import arviz as az


# Creazione delle coordinate per una griglia 51x51
x = np.linspace(0, 50, 51)
y = np.linspace(0, 50, 51)
X, Y = np.meshgrid(x, y)

# Rappresentazione dei punti della griglia
plt.scatter(X, Y, color='black', s=1)  # s=1 imposta la dimensione dei punti

# Assicura che la griglia sia quadrata e rimuove gli assi per pulizia
plt.axis('equal')
plt.axis('off')

# Salvataggio dell'immagine
plt.show()


# 1. Setup della griglia (51x51, coordinate da 0 a 50)
grid_size = 51
steps = 50
num_walks = 5

# Il centro della griglia (punto di partenza)
start_pos = grid_size // 2  # 51 // 2 = 25

# 2. Creazione del grafico della griglia di sfondo
x_grid, y_grid = np.meshgrid(np.arange(grid_size), np.arange(grid_size))
plt.scatter(x_grid, y_grid, color='lightgray', s=1, alpha=0.5)

# 3. Simulazione dei 5 Random Walks
for i in range(num_walks):
    # Ogni cammino parte dal centro [25, 25]
    x, y = [start_pos], [start_pos]
    
    current_x, current_y = start_pos, start_pos
    
    for _ in range(steps):
        # Definiamo i possibili passi: -1, 0, o 1 per ogni direzione
        # Escludendo il passo (0,0) per muoversi sempre
        dx, dy = 0, 0
        while dx == 0 and dy == 0:
            dx = np.random.choice([-1, 0, 1])
            dy = np.random.choice([-1, 0, 1])
        
        # Aggiornamento posizione con logica "wrap-around" (operatore modulo %)
        current_x = (current_x + dx) % grid_size
        current_y = (current_y + dy) % grid_size
        
        x.append(current_x)
        y.append(current_y)
    
    # Plot del cammino
    plt.plot(x, y, marker='o', markersize=3, label=f'Walk {i+1}')
ticks = np.arange(0, 51, 10) 

plt.xticks(ticks)
plt.yticks(ticks)

# Opzionale: per vedere meglio i tick, assicurati che gli assi siano visibili
plt.axis('on') 
plt.title(f"{num_walks} Random Walks (50 steps)")
plt.axis('equal')
plt.show()



def merge_walks(walk1: List[Tuple[int, int]], walk2: List[Tuple[int, int]]) -> List[Tuple[int, int]]:
    """
    Computes a new walk alternating steps from two paths.
    
    >>> merge_walks([(0,0), (1,1), (1,2), (1,3)], [(1,0), (0,1)])
    [(0, 0), (1, 1), (0, 2), (0, 3), (0, 4)]
    """
    
    # Questa funzione è ora "figlia" di merge_walks
    def get_steps(walk):
        steps = []
        for i in range(1, len(walk)):
            dx = walk[i][0] - walk[i-1][0]
            dy = walk[i][1] - walk[i-1][1]
            steps.append((dx, dy))
        return steps

    # Tutto questo blocco deve essere indentato per stare dentro merge_walks
    steps1 = get_steps(walk1)
    steps2 = get_steps(walk2)
    
    combined_steps = []
    max_len = max(len(steps1), len(steps2))
    
    for i in range(max_len):
        if i < len(steps1):
            combined_steps.append(steps1[i])
        if i < len(steps2):
            combined_steps.append(steps2[i])
            
    res = [(0, 0)]
    for dx, dy in combined_steps:
        last_x, last_y = res[-1]
        res.append((last_x + dx, last_y + dy))
        
    return res

if __name__ == "__main__":
    import doctest
    # verbose=True ti permette di vedere i test anche se passano con successo
    doctest.testmod()



# Caricamento del file iris.csv in un DataFrame
# Assicurati che il file si trovi nella stessa cartella del tuo script
df = pd.read_csv('iris.csv')

# Visualizzazione delle prime righe per conferma
print(df.head())


# 2. Aggiungiamo la colonna per il rapporto tra larghezza petalo e larghezza sepalo
# Assumiamo i nomi standard delle colonne (petal_width, sepal_width)
df['petal_sepal_width_ratio'] = df['petal width'] / df['sepal width']

# 3. Aggiungiamo la colonna per il rapporto tra lunghezza petalo e lunghezza sepalo
df['petal_sepal_length_ratio'] = df['petal length'] / df['sepal length']

# Visualizziamo il risultato
print(df.head())



# Supponendo che il dataframe df dell'Ex 6 sia già caricato
# df = pd.read_csv('iris.csv') ... (operazioni Ex 6)

# 1. Creazione della figura con due subplot (1 riga, 2 colonne)
fig, (ax1, ax2) = plt.subplots(1, 2, figsize=(12, 5))

# Lista delle classi (specie) uniche nel dataset
species = df['class'].unique()
colors = ['blue', 'orange', 'green']

# 2. Plot dell'istogramma di SINISTRA (Width Ratios)
for s, col in zip(species, colors):
    subset = df[df['class'] == s]
    ax1.hist(subset['petal_sepal_width_ratio'], bins=15, alpha=0.5, label=s, color=col)

ax1.set_title('Petal/Sepal Width Ratio')
ax1.set_xlabel('Ratio')
ax1.set_ylabel('Frequency')
ax1.legend()

# 3. Plot dell'istogramma di DESTRA (Length Ratios)
for s, col in zip(species, colors):
    subset = df[df['class'] == s]
    ax2.hist(subset['petal_sepal_length_ratio'], bins=15, alpha=0.5, label=s, color=col)

ax2.set_title('Petal/Sepal Length Ratio')
ax2.set_xlabel('Ratio')
ax2.set_ylabel('Frequency')
ax2.legend()

# Ottimizzazione degli spazi tra i grafici
plt.tight_layout()
plt.show()

# 1. Preparazione dei dati: prendiamo solo la sepal_width delle Iris-setosa
# Assicurati che il nome della colonna e della specie corrispondano al tuo CSV
setosa_data = df[df['class'] == 'Iris-setosa']['sepal width'].values

# 2. Definizione del Modello Statistico con PyMC
with pm.Model() as model:
    # Prior: le nostre stime iniziali (λ=1 significa scala=1/1=1)
    # Usiamo l'esponenziale per mu (media) e sigma (dev. std) come richiesto
    mu = pm.Exponential('mu', lam=1.0)
    sigma = pm.Exponential('sigma', lam=1.0)
    
    # Likelihood: come pensiamo siano distribuiti i dati osservati
    # Il problema dice che la larghezza del sepalo è distribuita normalmente
    observed = pm.Normal('observed', mu=mu, sigma=sigma, observed=setosa_data)
    
    # 3. Campionamento (Inference)
    # draw=1000 genera mille campioni della distribuzione posterior
    trace = pm.sample(1000, return_inferencedata=True)

# 4. Plot dei risultati
az.plot_trace(trace)
plt.tight_layout()
plt.show()

# 5. Stampa dei valori richiesti (confronto con i dati reali)
print(f"Media campionaria (osservata): {np.mean(setosa_data):.3f}")
print(f"Deviazione standard (osservata): {np.std(setosa_data):.3f}")

# Puoi anche stampare il riassunto della posterior calcolata da PyMC
print("\nRiassunto della Posterior (PyMC):")
print(az.summary(trace, round_to=3))

